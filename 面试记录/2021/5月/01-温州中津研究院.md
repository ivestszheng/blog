## 流程

手写面试题——技术小组长面——CTO面

## 面试题

> 内容包括HTML、CSS、JS、Vue、Git

### 01-HTML

#### 01.HTML中行内元素和块级元素有哪些？两者有什么区别？

行内元素：`<span>、<a>、 <img>、 <input>、<textarea>、<select>、<label>`

块级元素：`<div>、<table>、<form>、<p>、<ul>、<h1>......<h6>、<hr> 、<pre>、<address>、<center>、<marquee> 、<blockquote>`

二者区别：

- 块级元素：
  1. 总是从新的一行开始，即各个块级元素独占一行，默认垂直向下排列
  2. 高度、宽度、margin及padding都是可控的，设置有效，有边距效果
  3. 宽度没有设置时，默认为100%
  4. 块级元素中可以包含块级元素和行内元素
- 行内元素：
  1. 和其他元素都在一行，即行内元素和其他行内元素都会在一条水平线上排列
  2. 高度、宽度是不可控的，设置无效，由内容决定



#### 02.header、nav、section、aside、article、footer这些标签有什么含义？

> 这些都是H5中的语义标签，具体理解可以看下图

![语义标签](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/20210512201642.png)

- `<section>` 表示区块
- `<article>` 表示文章。如文章、评论、帖子、博客
- `<header>` 表示页眉
- `<footer>` 表示页脚
- `<nav>` 表示导航
- `<aside>` 表示侧边栏。如文章的侧栏
- `<figure>` 表示媒介内容分组。
- `<mark>` 表示标记 (用得少)
- `<progress>` 表示进度 (用得少)
- `<time>` 表示日期

本质上新语义标签与`<div>`、`<span>`没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别，可以理解成`<div class="nav">` 相当于`<nav>`。



### 02-CSS

#### 01.考察CSS属性选择器

略



#### 02.如何让一个块级元素水平垂直居中

> 有多种写法，展示如下

在 CSS 中对元素进行水平居中是非常简单的：如果它是一个行内元素，就对它的父容器应用 `text-align: center`；如果它是一个块级元素，就对它自身应用 `margin: auto`或者 `margin: 0 auto`。

但是，如果要对一个元素垂直居中，`margin: auto`就行不通了。

##### 方式一：绝对定位 + margin（需要指定子元素的宽高，不推荐）

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .father{
            position: relative;
            min-height: 500px;
            background: pink;
        }
        .son {
            position: absolute;
            width: 200px;
            height: 100px;
            background: red;
            top: 50%;
            left: 50%;
            margin-top: -50px;
            margin-left: -100px;
        }
    </style>
</head>
<body>
    <div class="father">
        <div class="son">子元素的内容</div>
    </div>
    <script></script>
</body>
</html>

```

**代码解释**：我们先让子元素的左上角居中，然后向上移动宽度的一半(50px)，就达到了垂直居中的效果；水平居中的原理类似。

**不足之处**：要求指定子元素的宽高，才能写出 `margin-top` 和 `margin-left` 的属性值。

但是，在通常情况下，对那些需要居中的元素来说，其宽高往往是由其内容来决定的，不建议固定宽高。

##### 方式二：绝对定位 + translate（无需指定子元素的宽高，推荐）

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .father{
            position: relative;
            min-height: 500px;
            background: pink;
        }
        .son {
            position: absolute;
            background: red;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div class="father">
        <div class="son">子元素的内容</div>
    </div>
    <script></script>
</body>
</html>
```

这种写法，在没有指定子元素宽高的情况下，也能让其在父容器中垂直居中。因为 translate() 函数中使用百分比值时，是以这个元素自身的宽度和高度为基准进行换算和移动的（**动态计算宽高**）。

##### 方式3：flex 布局（待改进）

将父容器设置为 Flex 布局，再给父容器加个属性`justify-content: center`，这样的话，子元素就能水平居中了；再给父容器加个属性 `align-items: center`，这样的话，子元素就能垂直居中了。

代码举例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .father{
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: pink;
        }
        .son {
            background: red;
        }
    </style>
</head>
<body>
    <div class="father">
        <div class="son">子元素的内容</div>
    </div>
    <script></script>
</body>
</html>

```

上面这种写法，不足之处在于：给父容器设置属性`justify-content: center`和`align-items: center`之后，导致父容器里的所有子元素们都垂直居中了（如果父容器里有多个子元素的话）。可我明明想让指定的**某个子元素**居中，要怎么改进呢？

##### 方式4： flex 布局 + margin: auto（推荐）

我们只需写两行声明即可：先给父容器设置 `display: flex`，再给指定的子元素设置我们再熟悉不过的 `margin: auto`，即可让这个指定的子元素在**剩余空间**里，水平垂直居中。大功告成。

代码举例：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        .father{
            display: flex;
            min-height: 100vh;
            background: pink;
        }
        .son {
            margin: auto;
            background: red;
        }
    </style>
</head>
<body>
    <div class="father">
        <div class="son">子元素的内容，想水平垂直居中</div>
        <div class="son2">这个元素不想水平垂直居中</div>
    </div>
    <script></script>
</body>
</html>
```

请注意，当我们给父容器使用 Flex 布局 时，子元素的`margin: auto`不仅能让其在水平方向上居中，**垂直方向上也是居中的**。

### 03-JS

#### 01.JS中有那些基本数据类型？有那些引用数据类型？它们之间的区别是？

JS中一共有六种数据类型。

- **基本数据类型（值类型）**：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。
- **引用数据类型（引用类型）**：Object 对象。

注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。

> 问：引用数据类型有几种？

> 答：只有一种，即 Object 类型。

**数据类型之间最大的区别**：

- 基本数据类型：参数赋值的时候，传数值。
- 引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。



#### 02.map、filter、find、findIndex的使用场景是哪些？

> 都是遍历方法，最大区别在于应用场景不同。

[这篇文章](https://juejin.cn/post/6844903870154588168)描述得非常形象

- map:可以简单地理解为映射

  ```js
  var arr=[1,2,3,4];
  console.log( arr.map((n)=>n*n) );//[1, 4, 9, 16]
  console.log( arr.map((n)=>n-1) );//[0, 1, 2, 3]
  ```

- filter:筛选过滤。

  ```js
  var users = [
    {name: "张含韵", "email": "zhang@email.com"},
    {name: "江一燕",   "email": "jiang@email.com"},
    {name: "李小璐",  "email": "li@email.com"}
  ];
  //获取所有人的email
  var emails=users.map(user=>user.email) 
  console.log(emails.join(',')) //"zhang@email.com", "jiang@email.com", "li@email.com"
  //获取指定人的email
  var liEmail=emails.filter(email=>/^li/.test(email))
  console.log(liEmail.join('')) //li@email.com
  ```

- find:返回第一个符合条件的对象。

  ```js
  [1, 4, -5, 10].find((n) => n < 0)    // -5
  ```

  ```html
  <script type="text/javascript">
  $(function(){ 								    //  等待DOM加载完毕.
  	$("#a1").find("#b1").css("background","red");
  	$("#a1 div").filter(":eq(1)").css("background","blue");
  })
  </script>
  <div id="a1" style="width:50px;height:50px;clear:both;background:#FC3">
      <div id="b1" style="width:10px;height:20px;">b1</div>
      <div id="b2" style="width:10px;height:20px;">b2</div>
      <div id="b3" style="width:10px;height:20px;">b3</div>
  </div>
  ```

- findIndex:返回第一个符合条件的索引号。



#### 03.交换a和b变量值有哪些方法？

##### 方法一：使用临时变量

```js
let temp = a
a = b
b = temp
```

下面的方案都不会有临时变量，其实不使用临时变量的思路都是让其中一个变量变成一个a和b都有关系的值，这样可以先改变另一个变量值， 最后改变原修改的变量值

##### 方式二：让a先变成a与b的‘和’（也可以换成a和b的差，一样的） ，’和‘减去b巧妙的得到了a的变量值赋予b ，再通过‘和'减去a的值得到了b的值赋予a

```js
a += b // 此时a的值为 原本的a与b之和
b = a - b // b = 和 - 原本b = 原本a
a -= b // a = 和 - 原本a = 原本b
```

还有变式，改为差的形式

```js
a -= b // a = a与b之差
b = a + b // b = 差 + b = 原本a
a = b - a // a = 原本a - 差 = 原本b
```

##### 方案三：使用异或运算

```js
a ^= b
b ^= a
a ^= b
```

不了解的可以看这篇：[异或运算实现两个数的交换](https://blog.csdn.net/moodfriend/article/details/105481585)

甚至可以这样

```js
a = (b^=a^=b)^a;
```

##### 方案四：把a先变成了一个对象，这个对象保存着应该交换后的键值对，最后赋值搞定

```js
a = {a:b,b:a};
b = a.b;
a = a.a;
```

##### 方案五：和上面的方法很像，只不过对象换成了数组

```js
a = [a,b];
b = a[0];
a = a[1];
```

##### 方案六：根据运算符优先级，首先执行b=a，此时的b直接得到了a的变量值，然后一步数组索引让a得到了b的值

```js
a = [b,b=a][0]
```



##### 方案七：利用了ES6的解构赋值语法，它允许我们提取数组和对象的值，对变量进行赋值

```js
[a,b] = [b,a]
```



#### 04.promise+setTimeout()+函数，判断输出。

> 调用setTimeout时，把函数参数，放到事件队列中，等主程序运行完，再调用。即便是时间值为0，它也会等主程序执行完再执行，如果主程序队列为空，就会直接调用。

例1：

```js
fun(){
   for(var i = 0;i < 10; i++){
     setTimeout(function (i) {//同步注册回调函数到异步的宏任务队列
       console.log(i);//执行此代码时，for循环已经执行完毕。
     },0);
   }
 },
 //输出结果：10个10
 //涉及知识点：JS循环机制、setTimeOut执行机制
```

> `Promise.resolve()`用于将现有对象转换为`Promise`对象，从而控制异步流程。
>  而立即`resolve`的`Promise`对象是在本轮“事件循环”（Event loop）的结束时，而不是在下一轮“事件循环”的开始时。

例2：

```js
setTimeout(function () {
  console.log('three');
}, 0);

Promise.resolve().then(function () {
  console.log('two');
});

console.log('one');

// one
// two
// three
```



### 04-Vue

#### 01.Vue中有哪些生命周期？数据初始化发生在哪个生命周期？

一张图方便理解（PS:图片来自网络）。

![Vue生命周期](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/20210512213148.png)

`beforeCreate/created/beforeMount/mounted`

生命周期函数主要分为三类

1. 创建期间的生命周期函数
   - beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性
   - created：实例已经在内存中创建OK，此时 data 和 methods 已经创建OK，此时还没有开始 编译模板。我们可以在这里进行Ajax请求。
   - beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中

   - mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示。（mounted之后，表示**真实DOM渲染完了，可以操作DOM了**）
2. 运行期间的生命周期函数
   - beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染DOM节点

   - updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了。
3. 销毁期间的生命周期函数
   - beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
   - destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。



#### 02.给一段代码，判断在哪里出问题

```vue
<ul>
    <li
        v-for="user in users"
        v-if="user.isActive"
        :key="user.id"
    >
        {{ user.name }}
    </li>
</ul>
```



> 考察vue的注意规范之v-if 与 v-for 一起使用

当 `v-if` 与 `v-for` 一起使用时，`v-for` 具有比 `v-if` 更高的优先级，这意味着 `v-if` 将分别重复运行于每个 `v-for` 循环中

所以，不推荐v-if和v-for同时使用，`Vue2`中会直接报错。

推荐使用方式：

```vue
<ul v-if="shouldShowUsers">
    <li
        v-for="user in users"
        :key="user.id"
    >
        {{ user.name }}
    </li>
</ul>
```

或者放在计算属性遍历

```js
computed: {
    activeUsers: function () {
        return this.users.filter(function (user) {
            return user.isActive
        })
    }
}
```

```vue
<ul>
    <li
        v-for="user in activeUsers"
        :key="user.id"
    >
        {{ user.name }}
    </li>
</ul>
```



#### 03.父子组件传值、兄弟组件传值、隔代传值如何实现？

内容太多，[这篇文章](https://blog.csdn.net/alokka/article/details/87104189)总结地非常完善。



### 05-Git

#### 01.自己常用的命令有哪些？如何实现回滚指定版本？

回退命令：

- git reset --hard HEAD^ 回退到上个版本
- git reset --hard HEAD~3 回退到前3次提交之前，以此类推，回退到n次提交之前
- git reset --hard commit_id 退到/进到，指定commit的哈希码（这次提交之前或之后的提交都会回滚）



## 技术小组长面

> 自我介绍——软件开发流程——简历上项目涉及知识点——实习内容——上份工作辞职原因——期望薪资

介绍了大学学习内容；注重软件开发流程，关心协同开发的能力；考察对于同步和异步的理解；考察对于Git操作的熟悉程度

## CTO面

> 自我介绍——实习内容——上份工作辞职原因——最低薪资要求

觉得作为应届生要的工资太高

## 面试结果

回去等通知