# 奥点广电云

## 01-流程

手写面试题——HR面——CTO面

## 02-面试题

> 计算机网络基础、JS

### OSI七层模型有哪些层级？TCP/IP有哪些层级？

`OSI`：物理层——数据链路层——网络层——传输层——会话层——表示层——应用层

![OSI七层模型](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/20210524172403.png)

`TCP/IP`:应用层——TCP传输控制层——IP网络层——链路层

### JS基础数据类型有哪些？

Number、String、Boolean、Null、 Undefined

### Promise的三种状态

pengding(进行中)/fulfilled(已成功)/rejected(已拒绝)

### 根据下列代码写出输出结果并给出解决方案

```js
for (var i = 0; i < 5; i++) {
    setTimeout(function () {
        console.log(i);
    },0);
}
```

输出结果为五个5。

`setTimeout`是异步执行，每一次循环`setTimeout`都被进任务队列里，等待执行。只有调用栈清空后才会执行任务队列里的任务。

也就是说它会等到for循环全部运行完毕后，才会执行`setTimeout`，但是当for循环结束后此时i的值已经变成了5。

#### 方案一：闭包

通过闭包，将i的变量驻留在内存中，当输出j时，引用的是外部函数的变量值i，i的值是根据循环来的，执行setTimeout时已经确定了里面的的输出了。

```js
for (var i=0; i<5; i++) {
    (j => {
        setTimeout(() => {
            console.log( j );
        }, 0);
    })(i);
}
```

#### 方案二：拆分结构

将setTimeout的定义和调用分别放到不同部分：

```js
function timer(i) {
    setTimeout( console.log(i), 0);
}
for (var i=0; i<5;i++) {
    timer(i);
}
```

#### 方案三：let

使用es6中的let

```js
for (let i=0; i<5; i++) {
    setTimeout( function timer() {
        console.log(i);
     }, 0 );
}
```

这个例子与第一个相比，只是把var更改成了let，可却得到了正确的结果。

因为for循环头部的let不仅将i绑定到for循环中，事实上它将其重新绑定到循环体的每一次迭代中，确保上一次迭代结束的值重新被赋值。setTimeout里面的function()属于一个新的域，通过var定义的变量是无法传入到这个函数执行域中的，通过使用let来声明块变量能作用于这个块，所以function就能使用i这个变量了；这个匿名函数的参数作用域和for参数的作用域不一样，是利用了这一点来完成的。这个匿名函数的作用域有点类似类的属性，是可以被内层方法使用的。

#### 方案四：setTimeout第三个参数

```js
for (let i=0; i<5; i++) {
    setTimeout(() => {
        console.log( i );
     }, 0, i );
}
```

查阅[MDN](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)之后发现，setTimeout函数不止有第三个参数，甚至后面可以紧跟无数个参数。

其原文函数形式如下：

```js
var timeoutID = scope.setTimeout(function[, delay, param1, param2, ...]);
var timeoutID = scope.setTimeout(function[, delay]);
var timeoutID = scope.setTimeout(code[, delay]);
```

> Additional parameters which are passed through to the function specified by functionor code once the timer expires.

> param1,param2...paramN作为前面的回调函数的附加参数.

可以通过简单的代码来理解。

```js
setTimeout((a,b,c) => {
   console.log(a,b,c)
}, 2000, "my", "name", "is starsion");
```

```js
my name is starsion
```

### 给定一个整数数组 nums 和一个目标值 target，请在该数组中找出和为目标值的那两个整数，并返回他们的数组下标（JS实现）。另外写出时间复杂度。

算法学习的还是太少，这里贴一下别人的解决[方案](https://blog.csdn.net/weixin_43936284/article/details/108223996)。

#### 方案一：暴力双循环法 （不推荐使用，时间复杂度高）

关键点在于第二层循环从哪开始，思路就是当前这个整数与之后的所有的数依次进行判断即相加是否等于target，而且比较过的不要再次比较，还要排除判断自身相加的情况。

```js
	var twoSum = function(nums, target) {
	                    let arr = nums;
	                    let arrs = new Array()
	                    for(let i =  0; i < arr.length - 1; i++){
	                        for(let j = i + 1; j < arr.length; j++){
	                            if ( arr[i] + arr[j] === target) {
	                                arrs.push(i, j)
	                                return arrs
	                            }
	                        }
	                    }
	                }
		console.log(twoSum([11,11,42,5,3,5],10))
```

#### 方案二：利用哈希表

利用哈希表将每一个整数与target目标数的差值和该证书的索引值，以键值对(差值，索引值)的方式存入哈希表，循环判断每一个整数在哈希表中是否存在与该整数相等的差值，若不存在将该整数对应的差值以及对应的索引值存入哈希表，若存在即说明在之前的循环遍历中已经出现了与当前循环整数相加等于target的整数，这就已经找到了和为目标值的两个整数。
说直白点就是将数组中整数的差值一个一个放入哈希表，当出现了当前整数等于之前循环遍历的整数差值的情况，就说明这两个数已经找到了。当前整数 = 之前整数的差值 ， 之前整数的差值 = target - 之前的整数 ，当前整数 + 之前的整数 = target。

```js
const twoSum = (nums, target) => {
  // 1. 构造哈希表
  const map = new Map(); // 存储方式 {need, index}

  // 2. 遍历数组
  for (let i = 0; i < nums.length; i++) {
    // 2.1 如果找到 target - nums[i] 的值
    if (map.has(nums[i])) {
      return [map.get(nums[i]), i];
    } else {
      // 2.2 如果没找到则进行设置
      map.set(target - nums[i], i);
    }
  }
};

console.log(twoSum([3,2,5,7], 9)); // [0, 1]

```

## 03-HR面

> 项目展示——职业规划—— ~~闲谈~~ ——浏览器如何运作——TCP/IP握手挥手过程——对于微服务理解——如何设计功能（以电梯为例）——几个心理测试问题

## 04-CTO面

> 项目展示——GitHub展示——实习内容——对低代码开发的看法——有无项目部署的经历

简单地交流了如何去实现低代码开发，不过这块内容之前没有涉及过，大部分时间以听为主。

## 05-面试结果

当天收到offer

