# Vue权限控制

## 前言

侧重讲前端权限控制与 Vue 中实现思路。

## 权限相关概念

### 权限的分类

#### 后端权限

从本质上来讲前端仅仅只是视图层的展示，权限的核心是在于服务器中的数据变化，所以后端才是权限的关键，后端权限可以控制某个用户是否能够查询数据，是否能够修改数据等操作。

> 目前被大家广泛采用的两种权限模型为：基于角色的访问控制（RBAC）和基于属性的访问控制（ABAC），二者各有优劣：
>
> - RBAC 模型（用户、角色、权限）构建起来更加简单，缺点在于无法做到对资源细粒度地授权（都是授权某一类资源而不是授权某一个具体的资源）。
> - ABAC 模型构建相对比较复杂，学习成本比较高，优点在于细粒度和根据上下文动态执行。

#### 前端权限

前端权限的控制本质是控制前端**视图层的展示**和前端所发送的**请求**，但是前端的权限都是可以通过技术手段破解的，不能将系统安全寄希望于前端。

### 前端权限的意义

如果仅从能够修改服务器中数据库的数据层面上讲，确实只在后端做控制就足够了，进行前端权限控制的好处主要如下：

- 仅展示用户权限内的内容，避免界面误导用户，提高用户体验
- 排除不必要的请求，减轻服务器压力

## 前端权限控制思路

### 路由控制

在登录请求中会得到权限的数据。前端根据权限去动态生成路由，只允许用户访问权限内的路由，如果通过地址栏去访问权限外的路由会重定向至`/404`页面(无论登录了还是没登录)。

### 按钮控制

同一页面还可能因为权限不同展示不同的按钮。

### 请求和响应的控制

如果用户通过非常规操作，比如通过浏览器调试工具将某些禁用的按钮变成启用状态。此时发的请求，也应该被前端所拦截。

## Vue权限控制的实现

### 获取权限信息

一般权限信息会在用户登录后由后端返回，具体如何控制权限要看前端是如何与后端约定的。在查找资料并结合个人项目经验后，我总结有以下有三种常见的方式。

#### 后端返回权限表或路由表

这种方式常见于管理员可以添加新角色，并且要给这个角色分配菜单。拿到的数据大概如下：

```javascript
{
 "data": {
     "id": 1,
     "username": "admin",
     "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTY1MzM1NzIyNH0.1y-Ucq_MfFRloesg0eA9pfk-VA3pV_zAOSj3HFpnKak"
 },
 "rights": [
  {
      "id": 125,
      "authName": "用户管理",
      "icon": "icon-user",
      "children": [
          {
              "id": 110,
              "authName": "用户列表",
              "path": "users",
              "rights": ["view","edit","add","delete"]
          }
      ]
  },
  {
      "id": 103,
      "authName": "角色管理",
      "icon": "icon-juese",
      "rights": ["view","edit","add","delete"]
  }
 ]
}
```

`data`中是用户信息，其中重点关注`token`字段，需要在客户端对其进行持久化处理。在请求需要鉴权的接口时，需要将其放在请求头中传给后端。如果使用`axios`进行网络请求，可以通过拦截器`interceptors`来处理——请求拦截器携带`token`，响应拦截器处理`token`过期，具体代码如下：

```js
import axios from 'axios';
import router from '../router/index';

// create an axios instance
const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_URL,
  withCredentials: false, // send cookies when cross-domain requests
  headers: { 'Content-Type': 'application/json;charset=UTF-8' },
  timeout: 10000, // request timeout
});

// 添加请求拦截器
service.interceptors.request.use(
  // do something before request is sent
  (config) => {
    const token = sessionStorage.getItem('token');
    if (token) {
      // 判断token是否存在
      config.headers.Authorization = `Bearer ${token}`; // 将token设置成请求头
    }
    return config;
  },
  (error) => {
    // do something with request error
    console.error(error); // for debug
    return Promise.reject(error);
  }
);

// 添加响应拦截器
service.interceptors.response.use(
  (response) => {
    const { data } = response;

    return data;
  },
  (error) => {
    console.error(error); // for debug
    if (error.response.status) {
      switch (error.response.status) {
        case 403: // token 过期
          Message.error('身份认证失效，请重新登录');
          router.replace({
            path: '/',
          });
          break;
        default:
          break;
      }
    }

    return Promise.reject(error);
  }
);

export default service;
```

使用`session`鉴权也是同样的思路，`cookie`则是需要设置`withCredentials`为`true`。

权限表`rights`经过处理可以生成前端需要的路由表（这里展示的是`父子结构`，也可能拿到是`一维数组`，需要前端自己处理），如果返回的是路由表则无需额外的处理，具体内容我们放在`路由控制的实现`中来说。

#### 后端返回角色信息

对于一些小项目来说，后端可能不想返回路由表，前端也觉得加一个页面要后端改一下太麻烦了。更常见的情况，后端会告诉前端用户的角色，数据大概如下：

```js
{
    "data": {
     "id": 1,
     "username": "admin",
     "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTY1MzM1NzIyNH0.1y-Ucq_MfFRloesg0eA9pfk-VA3pV_zAOSj3HFpnKak",
     "roles": ['admin','editr']
 }
}
```

`roles`字段代表了用户的角色，用数组是因为一个用户可能有多个角色。路由表由前端来维护并根据角色动态生成。

#### 前端根据用户信息判断角色

后端也可能这样的用户信息，如下所示：

```js
{
    "data": {
     "id": 1,
     "username": "admin",
     "token": "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJhZG1pbiIsImlhdCI6MTY1MzM1NzIyNH0.1y-Ucq_MfFRloesg0eA9pfk-VA3pV_zAOSj3HFpnKak",
     "level": 1，
     "units": {
             "id": 1,
             "name": "部门1"
         }
 }
}
```

一开始后端告诉你通过`level`字段判断权限，你很快写好了方法。随着业务的变动，产品提出了新的需求，增加了管理员，后端告诉你：

> 当`username`为`admin`时角色是管理员。

过了一段时间，又告诉你：

> 当`units`为`null`时是特殊角色，只有导入数据的权限。

那你可能会写出这样一个方法来判断用户的权限等级：

```js
    function getUserAuthority() {
      const userInfo = JSON.parse(sessionStorage.getItem('userData')).currentUserInfo;
      const { username, units } = userInfo;

      if (units === null) return -1;
      if (username === 'admin') return 0;
      return units?.level;
    }
```

尽管数据库中表还是原来的表，但是从前端的角度来看，假设原先`level`只有`1`、`2`、`3`三个等级，相当于三个角色，现在则是变成了5个角色。

### 路由控制的实现

如果我们能直接拿到路由表，或是将权限表处理成这样子。

```js
[
    {
        path: '/',
        component: Layout,
        children: [
            {
                path: '',
                name: 'Users'
            }
        ]
    }
]
```

### 按钮控制的实现

### 请求和响应的控制的实现

## 总结

## 参考

1. [bilibili - 后台系统的权限控制与管理](https://www.bilibili.com/video/BV15Q4y1K79c?spm_id_from=333.337.search-card.all.click)
