## 前言

本文将阐述我个人从零开始构建一个 H5 项目以及在后续一年的持续迭代的过程中，做了哪些工作，踩了哪些坑，收获了什么思考。项目可在浙里办搜索**《青科汇》**。

## 技术选型

### 主要技术栈

- [Vue@3.2](https://link.juejin.cn/?target=mailto%3AVue%403.2)
- [TypeScript@5.4](https://link.juejin.cn/?target=mailto%3ATypeScript%405.4)
- [VueCli@5](https://cli.vuejs.org/zh/)
- [VantUi@3.5](https://link.juejin.cn/?target=mailto%3AVantUi%403.5)
- [Pinia@2](https://pinia.vuejs.org/introduction.html)
- [Axios@0.27](https://link.juejin.cn/?target=mailto%3AAxios%400.27)

### 技术选型

#### Vue2 还是 Vue3

选择 Vue3 的理由如下：

- 更高效的 diff 算法。
- 更好的开发体验。
- 更有生命力的社区支持。

#### Vite 还是 Webpack

没有选用 Vite 的主要原因在于项目是通过 VueCli 构建的，我对这一套生态更加熟悉。加上当时了解到工期很紧，害怕使用 Vite 踩坑拖慢项目进度。不过处在2023年这一节点， VueCli 已经进入了维护模式很久了，官方推荐使用 VueCreate 构建项目。再加上 VueConf2022 上看到许多大公司已经将 Vite 用于生产环境，下一次构建项目时我会选择 VueCreate 与 Vite。

#### Pinia 还是 Vuex

毫无疑问是 Pinia，它非常轻量，使用起来相当简洁。而且尤大在一次掘金的直播中明确表示了 Pinia 就是下一代 Vuex，出于对作者的尊重所以没有改名。

#### Vant

老牌组件库，成熟的使用方案与优秀的文档，我个人开发移动端时最常用的组件库。

## 功能开发

### 拉平 RPC 模式下的开发体验

> RPC 服务器是指 Remote Procedure Call Protocol，中文释义为远程过程调用协议：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。

阿里承建的 IRS 平台就是使用的 RPC 模式，另一个比较熟悉的例子微信小程序的云函数。

RPC 模式下，客户端要先将请求发送至 RPC 服务器，再由 RPC 服务器转发给我们自己的服务器。这导致生产环境与开发环境使用的网络请求库并不一致，提高了开发成本。为了降低开发时的心智负担，我针对我们自己的项目封装了一个请求方法，在不影响原有能力的基础上，调用者不再需要关心背后的具体实现，开发环境与生产环境的表现一致。封装的请求方法`request`及使用如下：

```typescript
// 封装的请求方法 request.ts
import mgop from "./mgop";
import axiosInstance from "./axiosInstance";

type RequestResponse = {
  code: number;
  data: any;
  message: string;
};

/**
 * 自定义的请求函数，用来拉平开发环境与平台体验，开发环境使用 axios，线上与测试环境使用 mgop 。
 * 由于后端响应失败时，平台自己的异常信息，导致无法拿到后端抛出的异常信息。所以与后端约定返回的数据结构永远包含
 * data,code,messge 三个字段，http 状态码永远为 200，真实的响应状态与信息通过响应体中的 code 与 message 来判断。
 * @param apis api 请求地址 dev 代表通过 axios 请求的路径，prod 代表通过 Mgop 请求的路径。
 * @param type 请求类型 get 或 post 。
 * @param config 配置项，会解构为 mgop 与 axios 的参数，主要用来添加请求体 data 。
 */
function request(
  apis: { dev: string; prod?: string },
  type: "get" | "post",
  config?: { data?: Record<string, any> }
): Promise<RequestResponse> {
  if(开发环境) {
      // 使用 axios
  } else {
      // 使用 mgop 
  }
}

export default request;
```

可以看到，使用 `request`这个方法之后，返回的始终是结构为 `RequestResponse` 的 `Promise` 对象。

### Hooks 复用有状态逻辑

"hooks" 直译是 “钩子”，它并不仅是 `react`，甚至不仅是前端界的专用术语，而是整个行业所熟知的用语。通常指：

> 系统运行到某一时期时，会调用被注册到该时机的回调函数。

比较常见的钩子有：`windows` 系统的钩子能监听到系统的各种事件，浏览器提供的 `onload` 或 `addEventListener` 能注册在浏览器各种时机被调用的方法。

以上这些，都可以被称一声 "hook"。

以 `vue` 为例，`hooks` 是：

> 在 `vue` 组合式API里，以 `“use”` 作为开头的，一系列提供了组件复用、状态管理等开发能力的方法。

相比于 `vue` 的 `mixin`，`hooks` 有点如下：

- 清晰的数据来源，方法和属性名方便追溯。
- 命名空间不会冲突，不存在重名、覆盖的问题。

基于上述理由，不再推荐在 Vue 3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。

除了自己编写 `hooks` ，还可以使用一些第三方库比如 `vueuse` 提升效率。

### Typescript 为代码质量提供支持

通过 `ts` ，`vscode` 可以及时地给予我类型提示。举个例子，比如我在项目中定义的一个通过接口进行分页查询的方法如下：

```typescript
/** 分页查询播放记录 */
const queryCloudRecords = ({
  page,
  pageSize,
}: {
  page: number;
  pageSize: number;
}): Promise<
  RequestResponse & {
    data: IPaginationResponse & { data: ISpeechCloudRecord[] };
  }
> => {
  return request(
   // ...
  );
};
```

```typescript
interface IPaginationResponse {
  total: number;
  page: number;
  size: number;
}
```

```typescript
/** 播放记录表 */
interface ISpeechCloudRecord {
  /** 播放记录 id */
  id: number;
  createTime: string;
  updateTime: string;
  createUserId: number;
  deleteTag: number;
  name: string;
  picUrl: string;
  title: string;
  userIdentity: string;
  /** 视频id */
  videoId: number;
  /** 视频时长(单位秒) */
  videoLength: number;
  /** 视频已播放时长(单位秒) */
  videoPlay: number;
}
```

接口响应成功，返回的数据结构如下：

```json
{
 code: 200,
 data: {
     total: 10,
     page: 0,
     size: 8,
     data: [
         {
             id: 1,
             // ...
         }，
         // ...
     ]
 },
 message: '成功'
}
```

在使用时，如果使用到了不存在的属性，`vscode` 会直接给予提示。

![image-20230619104507459](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619104507459.png)

## 终端适配方案

PC 端后台管理系统的屏幕尺寸相对较稳定，因此通常不需要复杂的自适应方案。我选择的是 `postcss-px-to-viewport` ，这也是手淘适配方案作者推荐的。

`postcss-px-to-viewport` 是一个基于 `PostCSS` 的插件，它可以将 CSS 中以 px 为单位的长度属性转换为在视口宽度上相对应的 vw 、vh 或者 vmin 等视口单位。

这个插件的作用是可以帮助我们自动处理不同终端设备的适配问题，避免在不同屏幕尺寸下显示效果不一致的问题，从而降低前端开发和维护成本。

使用 `postcss-px-to-viewport` 的好处主要有以下几点：

1. 方便快捷：只需要在项目中安装和配置一下该插件，即可自动将 CSS 中的 px 像素值转换为 vw、vh 或 vmin 等视口单位，无需手动计算；
2. 兼容性好：视口单位已经得到完善支持，在绝大多数移动设备和现代浏览器中均可以使用；
3. 更好的适配性：通过对不同屏幕尺寸自动适配，可以使页面在各种设备上展示的效果更一致、更美观，提升用户体验。

需要注意的是，使用 `postcss-px-to-viewport` 时需要根据具体情况进行参数配置，例如设置设计稿宽度、视口宽度、转换精度等参数。同时，也需要注意该插件可能会影响到一些特定的 CSS 属性，如 border、border-radius 等，请在使用时仔细查看并进行相应的配置。



## 调试方式

1. 官方的调试工具

   基本上官方的 `IDE` 都会携带调试功能，这里不赘述。

2. vConsole

   腾讯出品的 Web 调试面板，使用简单，基本可以满足普通前端开发的需求。

3. 抓包

   通过一些例如 `whistle` 的抓包工具，可以帮助开发者发现网络请求是否正常、数据传输是否正确、接口响应时间等问题。

## 规范与门禁

### 代码规范

项目集成了 `eslint`、`prettier`、`stylelint`，`eslint` 约束 `js` 语法，`stylelint` 约束 `css` 语法，`prettier` 统一代码格式。

### git 提交信息规范

集成了 `commitlint` ，参照 `Angular` 团队规范。为了便于使用，增加了交互式 Commit 。

![image-20230619131435341](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619131435341.png)

### 门禁

通过`husky` 和 `lint-staged` 只对暂存区中的文件执行操作。

![image-20230619132021963](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619132021963.png)

![image-20230619131933949](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619131933949.png)

## 脚本解决重复性工作

在项目中一些可能存在一些重复性工作，通过脚本一来可以提高效率，二来降低长期出错的概率。下图为项目中通过指令生成压缩文件。

![image-20230619133152932](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619133152932.png)

![image-20230619132948220](https://raw.githubusercontent.com/ivestszheng/images-store/master/img/image-20230619132948220.png)